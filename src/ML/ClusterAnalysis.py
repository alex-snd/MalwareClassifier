from os.path import join

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from matplotlib import cm
from sklearn.cluster import KMeans, DBSCAN
from sklearn.metrics import silhouette_samples

from src.Common import config
from src.Common.utils import get_data_base, get_file_id, get_ae2_latent_data_base_path


def elbow_method(data: pd.DataFrame, max_n_cluster: int = 20) -> None:
    distortions = []

    for i in range(1, max_n_cluster):
        km = KMeans(n_clusters=i,
                    init='k-means++',
                    n_init=15,
                    max_iter=300,
                    random_state=2531)

        km.fit(data)

        distortions.append(km.inertia_)

    plt.figure(figsize=(19.2, 10.8))
    plt.plot(range(1, max_n_cluster), distortions, marker='o', color='royalblue')
    plt.xlabel('Number of clusters')
    plt.ylabel('Distortion')
    plt.tight_layout()

    im_id = get_file_id(config.simple_analysis_path)
    plt.savefig(join(config.simple_analysis_path, f'elbow_{im_id:_>3}.png'), dpi='figure', bbox_inches='tight')
    # plt.show()


def silhouette_analysis(data: pd.DataFrame, prediction: np.ndarray, n_clusters: int, model_name: str) -> None:
    cluster_labels = np.unique(prediction)

    if n_clusters == 1:
        print('Count of clusters need to be more then 1')
        return

    silhouette_values = silhouette_samples(data, prediction, metric='euclidean')

    y_ax_lower, y_ax_upper = 0, 0
    y_ticks = []

    rainbow = cm.get_cmap('rainbow', n_clusters)
    colors = rainbow(np.linspace(0, 1, n_clusters))

    plt.figure(figsize=(19.2, 10.8))

    for i, c in enumerate(cluster_labels):
        c_silhouette_values = silhouette_values[prediction == c]
        c_silhouette_values.sort()

        y_ax_upper += len(c_silhouette_values)

        plt.barh(range(y_ax_lower, y_ax_upper), c_silhouette_values, height=1.0,
                 edgecolor='none', color=colors[i])

        y_ticks.append((y_ax_lower + y_ax_upper) / 2.)
        y_ax_lower += len(c_silhouette_values)

    silhouette_avg = np.mean(silhouette_values)

    plt.axvline(silhouette_avg, color="red", linestyle="--")
    plt.yticks(y_ticks, cluster_labels + 1)
    plt.ylabel('Cluster')
    plt.xlabel('Silhouette coefficient')

    plt.tight_layout()

    im_id = get_file_id(config.simple_analysis_path)
    plt.savefig(join(config.simple_analysis_path, f'silhouette_{n_clusters}_clusters_{model_name}_{im_id:_>3}.png'),
                dpi='figure', bbox_inches='tight')

    plt.clf()
    plt.close('all')


def scatter_prediction(data: pd.DataFrame, prediction: np.ndarray, n_clusters: int, model_name: str) -> None:
    dots = data.to_numpy()

    color_len = prediction.max(initial=1) / n_clusters
    ticks = list(np.arange(color_len / 2, n_clusters * color_len, color_len))

    color_map = cm.get_cmap('rainbow', n_clusters)

    fig, ax = plt.subplots(figsize=(19.2, 10.8))
    scatter = ax.scatter(dots[:, 0], dots[:, 1], c=prediction, cmap=color_map, marker='o', alpha=1.0)
    color_bar = fig.colorbar(scatter, ticks=ticks, ax=ax, drawedges=True)
    color_bar.ax.set_yticklabels([t + 1 for t in range(n_clusters)])
    ax.set_title(f'Latent space')
    fig.tight_layout()

    im_id = get_file_id(config.simple_analysis_path)
    plt.savefig(join(config.simple_analysis_path, f'scatter_{n_clusters}_clusters_{model_name}_{im_id:_>3}.png'),
                dpi='figure', format='png', bbox_inches='tight')

    plt.clf()
    plt.close('all')


def clustering_by_kmeans(data: pd.DataFrame, n_clusters: int = 8) -> None:
    km = KMeans(n_clusters=n_clusters,
                init='k-means++',
                n_init=10,
                max_iter=300,
                tol=1e-04,
                random_state=0)

    prediction = km.fit_predict(data)
    silhouette_analysis(data, prediction, n_clusters, model_name='KMeans')
    scatter_prediction(data, prediction, n_clusters, model_name='KMeans')


def clustering_by_dbscan(data: pd.DataFrame) -> None:
    e = 0.06
    db = DBSCAN(eps=e, min_samples=50, metric='euclidean')

    prediction = db.fit_predict(data)

    n_clusters = np.unique(prediction).shape[0]
    if n_clusters > 1:
        print(e, n_clusters)

    silhouette_analysis(data, prediction, n_clusters, model_name='DBSCAN')
    scatter_prediction(data, prediction, n_clusters, model_name='DBSCAN')


if __name__ == '__main__':
    data_base_path = get_ae2_latent_data_base_path('AE2_2_latent_database.csv')
    data_base = get_data_base(data_base_path, labels=False)
    print(f'Data base shape : {data_base.shape}')

    clustering_by_dbscan(data_base)
